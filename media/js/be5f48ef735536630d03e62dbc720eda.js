// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

var StickInParent = function(opts) {
  var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, outer_width, parent_selector, recalc_every, sticky_class;
  if (opts == null) {
    opts = {};
  }
  sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
  if (offset_top == null) {
    offset_top = 0;
  }
  if (parent_selector == null) {
    parent_selector = void 0;
  }
  if (inner_scrolling == null) {
    inner_scrolling = true;
  }
  if (sticky_class == null) {
    sticky_class = "is_stuck";
  }
  doc = $(document);
  if (enable_bottoming == null) {
    enable_bottoming = true;
  }
  outer_width = function(el) {
    var computed, w;
    if (window.getComputedStyle) {
      computed = window.getComputedStyle(el);
      w = parseFloat(computed.getPropertyValue("width")) + parseFloat(computed.getPropertyValue("margin-left")) + parseFloat(computed.getPropertyValue("margin-right"));
      if (computed.getPropertyValue("box-sizing") !== "border-box") {
        w += parseFloat(computed.getPropertyValue("border-left-width")) + parseFloat(computed.getPropertyValue("border-right-width")) + parseFloat(computed.getPropertyValue("padding-left")) + parseFloat(computed.getPropertyValue("padding-right"));
      }
      return w;
    } else {
      return el.getWidth() +
        parseInt(el.getStyle("padding-left"), 10) +
        parseInt(el.getStyle("padding-right"), 10) +
        parseInt(el.getStyle("margin-left"), 10) +
        parseInt(el.getStyle("margin-right"), 10);
    }
  };
  fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
    var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
    if (elm.readAttribute("sticky_kit")) {
      return;
    }
    elm.writeAttribute("sticky_kit", true);
    last_scroll_height = document.body.getHeight();
    parent = elm.up();
    if (parent_selector != null) {
      parent = parent_selector;
    }
    if (!parent) {
      throw "failed to find stick parent";
    }
    fixed = false;
    bottomed = false;
    spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : new Element("div");
    if (spacer) {
      spacer.setStyle('position', elm.getStyle('position'));
    }
    recalc = function() {
      var border_top, padding_top, restore;
      if (detached) {
        return;
      }
      last_scroll_height = document.body.getHeight();
      border_top = parseInt(parent.getStyle("border-top-width"), 10);
      border_top = isNaN(border_top) ? 0 : border_top; // IE10 returns 'medium'
      padding_top = parseInt(parent.getStyle("padding-top"), 10);
      padding_bottom = parseInt(parent.getStyle("padding-bottom"), 10);
      parent_top = parent.cumulativeOffset().top + border_top + padding_top;
      parent_height = parent.getHeight();
      if (fixed) {
        var tmp = recalc_counter;
        recalc_counter = null;
        tick(); // TM fix: prevent removeClassName without unstick event, when recalc_every is used
        recalc_counter = tmp;
        if (fixed) {
          fixed = false;
          bottomed = false;
          if (manual_spacer == null) {
            spacer.insert({
              after: elm
            });
            spacer.remove();
          }
          elm.setStyle({
            position: "",
            top: "",
            width: "",
            bottom: ""
          }).removeClassName(sticky_class);
          restore = true;
        }
      }
      top = elm.cumulativeOffset().top - (parseInt(elm.getStyle("margin-top"), 10) || 0) - offset_top;
      height = elm.getDimensions().height + parseInt(elm.getStyle("margin-top"), 10) + parseInt(elm.getStyle("margin-bottom"), 10);
      el_float = elm.getStyle("float");
      if (spacer) {
        spacer.setStyle({
          width: outer_width(elm) + 'px',
          height: height + 'px',
          display: elm.getStyle("display"),
          "vertical-align": elm.getStyle("vertical-align"),
          "float": el_float
        });
      }
      if (restore) {
        return tick();
      }
    };
    recalc();
    // if (height === parent_height) {
    //   return;
    // }
    last_pos = void 0;
    offset = offset_top;
    recalc_counter = recalc_every;
    tick = function() {
      var css, delta, recalced, scroll, will_bottom, win_height;
      if (detached) {
        return;
      }
      recalced = false;
      if (recalc_counter != null) {
        recalc_counter -= 1;
        if (recalc_counter <= 0) {
          recalc_counter = recalc_every;
          recalc();
          recalced = true;
        }
      }
      if (!recalced && document.body.getHeight() !== last_scroll_height) {
        recalc();
        recalced = true;
      }
      scroll = document.viewport.getScrollOffsets().top;
      if (last_pos != null) {
        delta = scroll - last_pos;
      }
      last_pos = scroll;
      if (fixed) {
        if (enable_bottoming) {
          will_bottom = scroll + height + offset > parent_height + parent_top;
          if (bottomed && !will_bottom) {
            bottomed = false;
            elm.setStyle({
              position: "fixed",
              bottom: "auto",
              top: offset + 'px'
            }).fire("sticky_kit:unbottom");
          }
        }
        if (scroll < top) {
          fixed = false;
          offset = offset_top;
          if (manual_spacer == null) {
            if (el_float === "left" || el_float === "right") {
              spacer.insert({
                after: elm
              });
            }
            spacer.remove();
          }
          css = {
            position: "",
            width: "",
            top: ""
          };
          elm.setStyle(css).removeClassName(sticky_class).fire("sticky_kit:unstick");
        }
        if (inner_scrolling) {
          win_height = document.viewport.getHeight();
          if (height + offset_top > win_height) {
            if (!bottomed) {
              offset -= delta;
              offset = Math.max(win_height - height, offset);
              offset = Math.min(offset_top, offset);
              if (fixed) {
                elm.setStyle({
                  top: offset + "px"
                });
              }
            }
          }
        }
      } else {
        if (scroll > top) {
          fixed = true;
          css = {
            position: "fixed",
            top: offset + 'px'
          };
          css.width = elm.getStyle("box-sizing") === "border-box" ?
            elm.getWidth() + parseInt(elm.getStyle("padding-left"), 10) + parseInt(elm.getStyle("padding-right"), 10) + "px" :
            elm.getWidth() - parseInt(elm.getStyle("border-left-width"), 10) - parseInt(elm.getStyle("border-right-width"), 10) + "px";
          elm.setStyle(css).addClassName(sticky_class);
          if (manual_spacer == null) {
            elm.insert({
              after: spacer
            });
            if (el_float === "left" || el_float === "right") {
              spacer.insert({
                bottom: elm
              });
            }
          }
          elm.fire("sticky_kit:stick");
        }
      }
      if (fixed && enable_bottoming) {
        if (will_bottom == null) {
          will_bottom = scroll + height + offset > parent_height + parent_top;
        }
        if (!bottomed && will_bottom) {
          bottomed = true;
          if (parent.getStyle("position") === "static") {
            parent.setStyle({
              position: "relative"
            });
          }
          return elm.setStyle({
            position: "absolute",
            bottom: padding_bottom + 'px',
            top: "auto"
          }).fire("sticky_kit:bottom");
        }
      }
    };
    recalc_and_tick = function() {
      recalc();
      return tick();
    };
    detach = function() {
      detached = true;
      document.stopObserving("touchmove", tick);
      document.stopObserving("scroll", tick);
      document.stopObserving("resize", recalc_and_tick);
      $(document.body).stopObserving("sticky_kit:recalc", recalc_and_tick);
      elm.stopObserving("sticky_kit:detach", detach);
      elm.writeAttribute("sticky_kit", false);
      elm.setStyle({
        position: "",
        bottom: "",
        top: "",
        width: ""
      });
      parent.setStyle("position", "");
      if (fixed) {
        if (manual_spacer == null) {
          if (el_float === "left" || el_float === "right") {
            spacer.insert({
              after: elm
            });
            // elm.insertAfter(spacer);
          }
          spacer.remove();
        }
        return elm.removeClassName(sticky_class);
      }
    };
    document.observe("touchmove", tick);
    document.observe("scroll", tick);
    document.observe("resize", recalc_and_tick);
    $(document.body).observe("sticky_kit:recalc", recalc_and_tick);
    elm.observe("sticky_kit:detach", detach);
    return setTimeout(tick, 0);
  };
  return {
    stick: function(el) {
      fn(el);
    }
  };
};

var EasyTabs = Class.create();
EasyTabs.prototype = {
    tpl: {
        tab    : '(.+)?',
        href   : '#product_tabs_(.+)?',
        content: 'product_tabs_(.+)?_contents'
    },
    config: {
        tabs     : '.easytabs-anchor',
        scrollSpeed: 0.5,
        scrollOffset: -5
    },

    initialize: function(container, options) {
        Object.extend(this.config, options || {});
        this.container = container;
        this.activeTabs = [];
        this.counters = {}; // Activity counters

        var isActivateFirstTab = !this.isExpandedLayout()
            && !this.container.hasAttribute('data-collapsed');

        if (this.container.hasAttribute("data-track-hash") && window.location.hash.length > 1) {
            if (this.activate(this.getTabByHref(window.location.hash), true)) {
                // some tab already activated so do not activate first tab
                isActivateFirstTab = false;
            }
        }

        Event.observe(window, "hashchange", function() {
            var href = window.location.hash;
            if (href.length <= 1) {
                var first = this.container.down(this.config.tabs);
                href = first.href || first.readAttribute('data-href');
            } else {
                if (-1 === href.indexOf('#tab_')) {
                    return;
                }
            }
            this.deactivate();
            this.activate(this.getTabByHref(href));
        }.bind(this));

        if (isActivateFirstTab) {
            var first = this.container.down(this.config.tabs);
            if ('undefined' !== typeof first) {
                this.activate(this.getTabByHref(first.href || first.readAttribute('data-href')));
            }
        }

        this.container.select(this.config.tabs).each(function(el ,i) {
            el.observe('click', this.onclick.bind(this, el));
            el.addClassName('easytabs-inited');

            var id = $(el).getAttribute('data-href');
            if (!id) {
                return;
            }
            $$(id + '_contents .pages a').each(function(_el){
                if (-1 == _el.href.indexOf("#")
                    && -1 !== _el.href.indexOf(window.location.host)) {

                    _el.href = _el.href + id;
                }
            });
        }.bind(this));

        var headerHeight = this.getThemeStickyHeaderHeight();
        if (this.container.hasAttribute('data-sticky-tabs')) {
            this.config.scrollOffset = -headerHeight;
            // appply sticky tabs
            this.stickTabsHeader();
        } else {
            this.config.scrollOffset -= headerHeight;
        }
    },

    /**
     * @param {String} tab      Tab to activate
     * @param {Boolean} scroll  lag to indicate that page should be scrolled to the tab
     * @return {String|false}   Activated tab of false if tab wasn't found
     */
    activate: function(tab, scroll, animate) {
        var content = this.getTabContent(tab);
        if (!content) {
            return false;
        }

        document.fire('easytabs:beforeActivate', {
            'tab'     : tab,
            'content' : content,
            'easytabs': this
        });

        if (-1 === this.activeTabs.indexOf(tab)) {
            this.activeTabs.push(tab);
        }

        this.getTabs(tab).each(function(a) {
            a.addClassName('active');
            var parentLi = a.up('li');
            parentLi && parentLi.addClassName('active');
        });
        if (!this.isExpandedLayout()) {
            this.openTab(tab, content);
            if (this.isTabsHeaderSticked()) {
                this.scrollToTab(tab, content, animate);
            }
        }
        if (scroll) {
            this.scrollToTab(tab, content, animate);
        }

        document.fire('easytabs:afterActivate', {
            'tab'     : tab,
            'content' : content,
            'easytabs': this
        });

        return tab;
    },

    openTab: function (tab, content) {
        this._updateCounter(tab);
        content.addClassName('active');
        content.show();
        if (this.container.hasClassName()) {}
    },

    scrollToTab: function (tab, content, animate) {
        Effect.ScrollTo(content, {
            duration: animate ? this.config.scrollSpeed : 0,
            offset: this.config.scrollOffset
        });
    },

    /**
     * @param {String} tab      Tab to deactivate
     * @return {String|false}   Last deactivated tab or false if tab not found
     */
    deactivate: function(tab) {
        if (!tab) {
            while (this.activeTabs.length) {
                this.deactivate(this.activeTabs[0]);
            }
            return tab;
        }

        var index = this.activeTabs.indexOf(tab);
        if (index > -1) {
            this.activeTabs.splice(index, 1);
        }

        var content = this.getTabContent(tab);
        if (!content) {
            return false;
        }

        document.fire('easytabs:beforeDeactivate', {
            'tab'     : tab,
            'content' : content,
            'easytabs': this
        });

        if (!this.isExpandedLayout()) {
            content.removeClassName('active');
            content.hide();
        }

        this.getTabs(tab).each(function(a) {
            a.removeClassName('active');
            var parentLi = a.up('li');
            parentLi && parentLi.removeClassName('active');
        });

        document.fire('easytabs:afterDeactivate', {
            'tab'     : tab,
            'content' : content,
            'easytabs': this
        });

        return tab;
    },

    /**
     * @param {Object} el       Element
     * @param {Object} e        Event
     * @param {String} tab      Tab to activate
     * @param {Boolean} scroll  Flag to indicate that page should be scrolled to the tab
     */
    onclick: function(el, e, tab, scroll, animate) {
        var isAccordion = false,
            accordionTrigger = this.container.down('.easytabs-a-accordion');
        if (accordionTrigger) {
            // accordion tabs are hidden for desktop
            isAccordion = (accordionTrigger.getStyle('display') !== 'none');
        }

        tab    = tab || this.getTabByHref(el.href || el.readAttribute('data-href'));
        scroll = scroll || el.hasClassName('easytabs-scroll');
        animate = animate || el.hasClassName('easytabs-animate');

        if (isAccordion) {
            if (el.hasClassName('active')) {
                this.deactivate(tab);
            } else {
                this.activate(tab, scroll, animate);
            }
        } else {
            this.deactivate();
            this.activate(tab, scroll, animate);
        }
    },

    /**
     * Retrieve tab name from the url
     *
     * @param {String} href
     */
    getTabByHref: function(href) {
        var tab = href.match(this.tpl.href + '$');
        if (!tab) {
            return false;
        }
        return tab[1];
    },

    /**
     * Update activation counter
     *
     * @param  {String} tab
     * @return void
     */
    _updateCounter: function(tab) {
        if (!this.counters[tab]) {
            this.counters[tab] = 0;
        }
        this.counters[tab]++;
    },

    /**
     * Retreive activation count for specified tab
     *
     * @param  {String} tab
     * @return {Integer}
     */
    getActivationCount: function(tab) {
        if (!this.counters[tab]) {
            this.counters[tab] = 0;
        }
        return this.counters[tab];
    },

    /**
     * Check is tabs with expanded layout
     *
     * @return {Boolean}
     */
    isExpandedLayout: function () {
        return $(this.container).hasClassName('expanded');
    },

    /**
     * Check is tabs header sticked at the moment
     *
     * @return {Boolean}
     */
    isTabsHeaderSticked: function () {
        var header = this.container.down('.easytabs-ul-wrapper');
        return header ? header.hasClassName('is_stuck') : false;
    },

    /**
     * Stick tabs header
     *
     * @return void
     */
    stickTabsHeader: function () {
        var tabsHeader = this.container.down('.easytabs-ul-wrapper'),
            tabsContent = this.container.down('.easytabs-content-wrapper'),
            stickyOptins = {
                offset_top: this.getThemeStickyHeaderHeight(),
                parent: this.container
            };
        // update tabs scroll offset when sticky tabs header enabled
        this.config.scrollOffset -= tabsHeader.getDimensions().height;
        if (this.isExpandedLayout()) {
            // MAGIC FOR EXPANDED LAYOUT
            // hide empty space of ul-wrapper becuase it has 'visibility: hidden'
            tabsHeader.setStyle({'margin-top': -tabsHeader.getDimensions().height + 'px'});
            stickyOptins.offset_top += tabsHeader.getDimensions().height;
        }
        // initialize sticky
        var sticky = new StickInParent(stickyOptins);
        sticky.stick(tabsHeader);
        // listen scroll to activate tab
        if (this.isExpandedLayout()) {
            Event.observe(
                window,
                'scroll',
                this._debounce(this.activateTabAfterScroll.bind(this), 50, false)
            );
        }
    },

    /**
     * Find active tab after scrolling
     *
     * @return void
     */
    activateTabAfterScroll: function () {
        var topScrollOffset = document.viewport.getScrollOffsets().top,
            self = this,
            maxNegative = -99999999,
            tabAlias = '';
        this.container.select('.tab-wrapper').each(function (el) {
            var distance = $(el).cumulativeOffset().top - topScrollOffset + self.config.scrollOffset;
            if (distance < 5 && distance >= maxNegative) {
                tabAlias = $(el).readAttribute('data-tab');
            }
        });
        if (tabAlias) {
            this.deactivate();
            this.activate(tabAlias, false, false);
        }
    },

    _debounce: function (func, wait, immediate) {
        var timeout;
        return function() {
            var context = this, args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    },

    getTabs: function (alias) {
        var href = this.tpl.href.replace(this.tpl.tab, alias);
        return this.container.select(
            this.config.tabs + '[href="' + href + '"]',
            this.config.tabs + '[data-href="' + href + '"]'
        );
    },

    getTabContent: function (alias) {
        var tabContentId = this.tpl.content.replace(this.tpl.tab, alias);
        tabContentId = tabContentId.replace(/\./g, '\\.'); // allow id with period
        return this.container.down('#' + tabContentId);
    },

    getThemeStickyHeaderHeight: function () {
        var stickyHeaderSelectors = [
                '.header-container[sticky_kit]', // flat sticky header
                '.header-content[sticky_kit]', // pure 2 sticky header
                '.nav-container[sticky_kit]' // luxury sticky header
            ],
            themeStickyHeader = $$(stickyHeaderSelectors.join(',')).first();
        return themeStickyHeader
            ? themeStickyHeader.getHeight()
            : 0;
    }
};

document.observe('dom:loaded', function(){
    window.easytabs = [];
    $$('.easytabs-wrapper').each(function (container){
        window.easytabs.push(new EasyTabs(container));
    })
    // initialize custom links
    if (easytabs.length) {
        var linkSelector = easytabs.first().config.tabs;
        $$(linkSelector).each(function (customLink){
            if (customLink.hasClassName('easytabs-inited')) {
                return;
            };
            customLink.observe('click', function(event) {
                var element = this;
                easytabs.each(function (tabs){
                    tab = tabs.getTabByHref(element.readAttribute('href'));
                    if (tab) {
                        tabs.onclick(element);
                        event.stop();
                        throw $break;
                    }
                });
            });
            customLink.addClassName('easytabs-inited');
        });
    };
});

